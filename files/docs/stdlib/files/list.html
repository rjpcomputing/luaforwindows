<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Luadocs for list.lua</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->

<h1>Modules</h1>
<ul>

	<li>
		<a href="../modules/base.html">base</a>
	</li>

	<li>
		<a href="../modules/bin.html">bin</a>
	</li>

	<li>
		<a href="../modules/debug.html">debug</a>
	</li>

	<li>
		<a href="../modules/fstable.html">fstable</a>
	</li>

	<li>
		<a href="../modules/getopt.html">getopt</a>
	</li>

	<li>
		<a href="../modules/io.html">io</a>
	</li>

	<li>
		<a href="../modules/lcs.html">lcs</a>
	</li>

	<li>
		<a href="../modules/list.html">list</a>
	</li>

	<li>
		<a href="../modules/math.html">math</a>
	</li>

	<li>
		<a href="../modules/mbox.html">mbox</a>
	</li>

	<li>
		<a href="../modules/object.html">object</a>
	</li>

	<li>
		<a href="../modules/package.html">package</a>
	</li>

	<li>
		<a href="../modules/parser.html">parser</a>
	</li>

	<li>
		<a href="../modules/set.html">set</a>
	</li>

	<li>
		<a href="../modules/std.html">std</a>
	</li>

	<li>
		<a href="../modules/strbuf.html">strbuf</a>
	</li>

	<li>
		<a href="../modules/string.html">string</a>
	</li>

	<li>
		<a href="../modules/table.html">table</a>
	</li>

	<li>
		<a href="../modules/tree.html">tree</a>
	</li>

</ul>



<!-- File list -->

<h1>Files</h1>
<ul>

	<li>
		<a href="../files/base.html">base.lua</a>
	</li>

	<li>
		<a href="../files/bin.html">bin.lua</a>
	</li>

	<li>
		<a href="../files/debug_ext.html">debug_ext.lua</a>
	</li>

	<li>
		<a href="../files/debug_init.html">debug_init.lua</a>
	</li>

	<li>
		<a href="../files/fstable.html">fstable.lua</a>
	</li>

	<li>
		<a href="../files/getopt.html">getopt.lua</a>
	</li>

	<li>
		<a href="../files/io_ext.html">io_ext.lua</a>
	</li>

	<li>
		<a href="../files/lcs.html">lcs.lua</a>
	</li>

	<li><strong>list.lua</strong></li>
	
	<li>
		<a href="../files/math_ext.html">math_ext.lua</a>
	</li>

	<li>
		<a href="../files/mbox.html">mbox.lua</a>
	</li>

	<li>
		<a href="../files/modules.html">modules.lua</a>
	</li>

	<li>
		<a href="../files/object.html">object.lua</a>
	</li>

	<li>
		<a href="../files/package_ext.html">package_ext.lua</a>
	</li>

	<li>
		<a href="../files/parser.html">parser.lua</a>
	</li>

	<li>
		<a href="../files/set.html">set.lua</a>
	</li>

	<li>
		<a href="../files/std.html">std.lua</a>
	</li>

	<li>
		<a href="../files/strbuf.html">strbuf.lua</a>
	</li>

	<li>
		<a href="../files/strict.html">strict.lua</a>
	</li>

	<li>
		<a href="../files/string_ext.html">string_ext.lua</a>
	</li>

	<li>
		<a href="../files/table_ext.html">table_ext.lua</a>
	</li>

	<li>
		<a href="../files/tree.html">tree.lua</a>
	</li>

	<li>
		<a href="../files/xml.html">xml.lua</a>
	</li>

</ul>






</div> <!-- id="navigation" -->

<div id="content">

<h1>File <code>list.lua</code></h1>


<p>Tables as lists.</p>






<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#append">append</a>&nbsp;(l, x)</td>
	<td class="summary">Append an item to a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#concat">concat</a>&nbsp;(...)</td>
	<td class="summary">Concatenate lists.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#cons">cons</a>&nbsp;(l, x)</td>
	<td class="summary">Prepend an item to a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#depair">depair</a>&nbsp;(ls)</td>
	<td class="summary">Turn a list of pairs into a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#elems">elems</a>&nbsp;(l)</td>
	<td class="summary">An iterator over the elements of a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#enpair">enpair</a>&nbsp;(t)</td>
	<td class="summary">Turn a table into a list of pairs.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#filter">filter</a>&nbsp;(p, l)</td>
	<td class="summary">Filter a list according to a predicate.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#flatten">flatten</a>&nbsp;(l)</td>
	<td class="summary">Flatten a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#foldl">foldl</a>&nbsp;(f, e, l)</td>
	<td class="summary">Fold a binary function through a list left associatively.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#foldr">foldr</a>&nbsp;(f, e, l)</td>
	<td class="summary">Fold a binary function through a list right associatively.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#indexKey">indexKey</a>&nbsp;(f, l)</td>
	<td class="summary">Make an index of a list of tables on a given field </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#indexValue">indexValue</a>&nbsp;(f, l)</td>
	<td class="summary">Copy a list of tables, indexed on a given field </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#map">map</a>&nbsp;(f, l)</td>
	<td class="summary">Map a function over a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#mapWith">mapWith</a>&nbsp;(f, l, ls)</td>
	<td class="summary">Map a function over a list of lists.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#new">new</a>&nbsp;(l, t)</td>
	<td class="summary">List constructor.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#project">project</a>&nbsp;(f, l)</td>
	<td class="summary">Project a list of fields from a list of tables.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#relems">relems</a>&nbsp;(l)</td>
	<td class="summary">An iterator over the elements of a list, in reverse.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#rep">rep</a>&nbsp;(l, n)</td>
	<td class="summary">Repeat a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#reverse">reverse</a>&nbsp;(l)</td>
	<td class="summary">Reverse a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#shape">shape</a>&nbsp;(s, l)</td>
	<td class="summary">Shape a list according to a list of dimensions.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#slice">slice</a>&nbsp;(l, from, to)</td>
	<td class="summary">Return a slice of a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tail">tail</a>&nbsp;(l)</td>
	<td class="summary">Return a list with its first element removed.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#transpose">transpose</a>&nbsp;(ls)</td>
	<td class="summary">Transpose a list of lists.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#zipWith">zipWith</a>&nbsp;(f, ls)</td>
	<td class="summary">Zip lists together with a function.</td>
	</tr>

</table>






<br/>
<br/>




<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="append"></a><strong>append</strong>&nbsp;(l, x)</dt>
<dd>
Append an item to a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list
	</li>
	
	<li>
	  x: item
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{l[1], ..., l[#l], x}</code>



</dd>




<dt><a name="concat"></a><strong>concat</strong>&nbsp;(...)</dt>
<dd>
Concatenate lists.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: lists
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{l<sub>1</sub>[1], ..., l<sub>1</sub>[#l<sub>1</sub>], ..., l<sub>n</sub>[1], ..., l<sub>n</sub>[#l<sub>n</sub>]}</code>



</dd>




<dt><a name="cons"></a><strong>cons</strong>&nbsp;(l, x)</dt>
<dd>
Prepend an item to a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list
	</li>
	
	<li>
	  x: item
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{x, unpack (l)}</code>



</dd>




<dt><a name="depair"></a><strong>depair</strong>&nbsp;(ls)</dt>
<dd>
Turn a list of pairs into a table. <br>FIXME: Find a better name.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ls: list <code>{{i<sub>1</sub>, v<sub>1</sub>}, ..., {i<sub>n</sub>, v<sub>n</sub>}}</code>
	</li>
	
</ul>






<h3>Return value:</h3>
table <code>{i<sub>1</sub>=v<sub>1</sub>, ..., i<sub>n</sub>=v<sub>n</sub>}</code>



</dd>




<dt><a name="elems"></a><strong>elems</strong>&nbsp;(l)</dt>
<dd>
An iterator over the elements of a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list to iterate over
	</li>
	
</ul>






<h3>Return values:</h3>
<ol>
	
	<li>iterator function which returns successive elements of the list
	
	<li>the list <code>l</code> as above
	
	<li><code>true</code>
	
</ol>



</dd>




<dt><a name="enpair"></a><strong>enpair</strong>&nbsp;(t)</dt>
<dd>
Turn a table into a list of pairs. <br>FIXME: Find a better name.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table <code>{i<sub>1</sub>=v<sub>1</sub>, ..., i<sub>n</sub>=v<sub>n</sub>}</code>
	</li>
	
</ul>






<h3>Return value:</h3>
list <code>{{i<sub>1</sub>, v<sub>1</sub>}, ..., {i<sub>n</sub>, v<sub>n</sub>}}</code>



</dd>




<dt><a name="filter"></a><strong>filter</strong>&nbsp;(p, l)</dt>
<dd>
Filter a list according to a predicate.


<h3>Parameters</h3>
<ul>
	
	<li>
	  p: predicate (function of one argument returning a boolean)
	</li>
	
	<li>
	  l: list of lists
	</li>
	
</ul>






<h3>Return value:</h3>
result list containing elements <code>e</code> of <code>l</code> for which <code>p (e)</code> is true



</dd>




<dt><a name="flatten"></a><strong>flatten</strong>&nbsp;(l)</dt>
<dd>
Flatten a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list to flatten
	</li>
	
</ul>






<h3>Return value:</h3>
flattened list



</dd>




<dt><a name="foldl"></a><strong>foldl</strong>&nbsp;(f, e, l)</dt>
<dd>
Fold a binary function through a list left associatively.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  e: element to place in left-most position
	</li>
	
	<li>
	  l: list
	</li>
	
</ul>






<h3>Return value:</h3>
result



</dd>




<dt><a name="foldr"></a><strong>foldr</strong>&nbsp;(f, e, l)</dt>
<dd>
Fold a binary function through a list right associatively.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  e: element to place in right-most position
	</li>
	
	<li>
	  l: list
	</li>
	
</ul>






<h3>Return value:</h3>
result



</dd>




<dt><a name="indexKey"></a><strong>indexKey</strong>&nbsp;(f, l)</dt>
<dd>
Make an index of a list of tables on a given field


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: field
	</li>
	
	<li>
	  l: list of tables <code>{t<sub>1</sub>, ..., t<sub>n</sub>}</code>
	</li>
	
</ul>






<h3>Return value:</h3>
index <code>{t<sub>1</sub>[f]=1, ..., t<sub>n</sub>[f]=n}</code>



</dd>




<dt><a name="indexValue"></a><strong>indexValue</strong>&nbsp;(f, l)</dt>
<dd>
Copy a list of tables, indexed on a given field


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: field whose value should be used as index
	</li>
	
	<li>
	  l: list of tables <code>{i<sub>1</sub>=t<sub>1</sub>, ..., i<sub>n</sub>=t<sub>n</sub>}</code>
	</li>
	
</ul>






<h3>Return value:</h3>
index <code>{t<sub>1</sub>[f]=t<sub>1</sub>, ..., t<sub>n</sub>[f]=t<sub>n</sub>}</code>



</dd>




<dt><a name="map"></a><strong>map</strong>&nbsp;(f, l)</dt>
<dd>
Map a function over a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  l: list
	</li>
	
</ul>






<h3>Return value:</h3>
result list <code>{f (l[1]), ..., f (l[#l])}</code>



</dd>




<dt><a name="mapWith"></a><strong>mapWith</strong>&nbsp;(f, l, ls)</dt>
<dd>
Map a function over a list of lists.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  l: 
	</li>
	
	<li>
	  ls: list of lists
	</li>
	
</ul>






<h3>Return value:</h3>
result list <code>{f (unpack (ls[1]))), ..., f (unpack (ls[#ls]))}</code>



</dd>




<dt><a name="new"></a><strong>new</strong>&nbsp;(l, t)</dt>
<dd>
List constructor. Needed in order to use metamethods.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: 
	</li>
	
	<li>
	  t: list (as a table)
	</li>
	
</ul>






<h3>Return value:</h3>
list (with list metamethods)



</dd>




<dt><a name="project"></a><strong>project</strong>&nbsp;(f, l)</dt>
<dd>
Project a list of fields from a list of tables.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: field to project
	</li>
	
	<li>
	  l: list of tables
	</li>
	
</ul>






<h3>Return value:</h3>
list of <code>f</code> fields



</dd>




<dt><a name="relems"></a><strong>relems</strong>&nbsp;(l)</dt>
<dd>
An iterator over the elements of a list, in reverse.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list to iterate over
	</li>
	
</ul>






<h3>Return values:</h3>
<ol>
	
	<li>iterator function which returns precessive elements of the list
	
	<li>the list <code>l</code> as above
	
	<li><code>true</code>
	
</ol>



</dd>




<dt><a name="rep"></a><strong>rep</strong>&nbsp;(l, n)</dt>
<dd>
Repeat a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list
	</li>
	
	<li>
	  n: number of times to repeat
	</li>
	
</ul>






<h3>Return value:</h3>
<code>n</code> copies of <code>l</code> appended together



</dd>




<dt><a name="reverse"></a><strong>reverse</strong>&nbsp;(l)</dt>
<dd>
Reverse a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list
	</li>
	
</ul>






<h3>Return value:</h3>
list <code>{l[#l], ..., l[1]}</code>



</dd>




<dt><a name="shape"></a><strong>shape</strong>&nbsp;(s, l)</dt>
<dd>
Shape a list according to a list of dimensions.  Dimensions are given outermost first and items from the original list are distributed breadth first; there may be one 0 indicating an indefinite number. Hence, <code>{0}</code> is a flat list, <code>{1}</code> is a singleton, <code>{2, 0}</code> is a list of two lists, and <code>{0, 2}</code> is a list of pairs. <br> Algorithm: turn shape into all positive numbers, calculating the zero if necessary and making sure there is at most one; recursively walk the shape, adding empty tables until the bottom level is reached at which point add table items instead, using a counter to walk the flattened original list. <br>


<h3>Parameters</h3>
<ul>
	
	<li>
	  s: <code>{d<sub>1</sub>, ..., d<sub>n</sub>}</code>
	</li>
	
	<li>
	  l: list to reshape
	</li>
	
</ul>






<h3>Return value:</h3>
reshaped list



</dd>




<dt><a name="slice"></a><strong>slice</strong>&nbsp;(l, from, to)</dt>
<dd>
Return a slice of a list. (Negative list indices count from the end of the list.)


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list
	</li>
	
	<li>
	  from: start of slice (default: 1)
	</li>
	
	<li>
	  to: end of slice (default: <code>#l</code>)
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{l[from], ..., l[to]}</code>



</dd>




<dt><a name="tail"></a><strong>tail</strong>&nbsp;(l)</dt>
<dd>
Return a list with its first element removed.


<h3>Parameters</h3>
<ul>
	
	<li>
	  l: list
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{l[2], ..., l[#l]}</code>



</dd>




<dt><a name="transpose"></a><strong>transpose</strong>&nbsp;(ls)</dt>
<dd>
Transpose a list of lists. This function in Lua is equivalent to zip and unzip in more strongly typed languages.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ls: <code>{{l<sub>1,1</sub>, ..., l<sub>1,c</sub>}, ..., {l<sub>r,1<sub>, ..., l<sub>r,c</sub>}}</code>
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{{l<sub>1,1</sub>, ..., l<sub>r,1</sub>}, ..., {l<sub>1,c</sub>, ..., l<sub>r,c</sub>}}</code>



</dd>




<dt><a name="zipWith"></a><strong>zipWith</strong>&nbsp;(f, ls)</dt>
<dd>
Zip lists together with a function.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  ls: list of lists
	</li>
	
</ul>






<h3>Return value:</h3>
<code>{f (ls[1][1], ..., ls[#ls][1]), ..., f (ls[1][N], ..., ls[#ls][N])</code> where <code>N = max {map (function (l) return #l end, ls)}</code>



</dd>


</dl>







</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>
